package domain

const (
	EventTypeKey      = "eventType"
	EventVersionKey   = "eventVersion"
	EventTimestampKey = "eventTimestamp"
	AggregateIdKey    = "aggregateId"
)

// domain events have these root properties
type EventRoot struct {
	EventType   string  `bson:"eventType" json:"eventType"`
	Version     float32 `bson:"eventVersrsionion" json:"eventVe"`
	Timestamp   int64   `bson:"eventTimestamp" json:"eventTimestamp"`
	AggregateId string  `bson:"aggregateId" json:"aggregateId"`
}

// domain events provide access to common root properties
type Event interface {
	Root() EventRoot
	FromMap(mapEvent map[string]interface{}) Event
}

func (e EventRoot) Root() EventRoot {
	return e
}

func (e EventRoot) FromMap(mapEvent map[string]interface{}) Event {
	e.EventType = mapEvent[EventTypeKey].(string)
	e.Version = mapEvent[EventVersionKey].(float32)
	e.Timestamp = mapEvent[EventTimestampKey].(int64)
	e.AggregateId = mapEvent[AggregateIdKey].(string)
	return e
}

/* aggregates accumulate domain events generated by business logic execution
following the execution of business logic these events should be stored
as an event log and dispatched as messages to other interested parties */
type Aggregate interface {
	Events() []Event
}

// append only domain event store
type EventStore interface {
	Append(events []Event, aggregateType string) (err error)
	EventsOf(aggregateId string, aggregateType string) (err error, events []map[string]interface{})
}

// domain event dispatcher
type EventPublisher interface {
	Dispatch(events []Event) (err error)
}
